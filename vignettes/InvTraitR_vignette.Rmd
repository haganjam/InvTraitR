---
title: "Dry biomass of freshwater invertebrates using InvTraitR"
author: "James Hagan"
date: "`r Sys.Date()`"
output: rmarkdown::html_vignette
---

To see how we can use *InvTraitR* to obtain estimates of the dry biomass of freshwater invertebrates using taxon names and geographical coordinates, we will start by loading some relevant packages and some test data. The test data consist of a set of 89 invertebrate taxa collected in freshwater rockpools on six rocky outcrops (often called inselbergs) in five countries.

In addition, the data consist of latitude-longitude coordinates for the samples as well as measured body lengths for all the taxa (some body lenghts were compiled from the literature)

```{r}
# until we can simply load the package, I'll load the functions and files manually

# load functions associated with the script
funcs <- list.files("R")
sapply(funcs, function(x) source(paste0("R/",x)))

# download the data files
db_files <- list("col_higher_taxon_matrices.rds",
                 "col_taxon_database.rds",
                 "equation_database.rds",
                 "freshwater_ecoregion_data.rds",
                 "freshwater_ecoregion_map.rds",
                 "freshwater_ecoregion_metadata.rds",
                 "gbif_higher_taxon_matrices.rds",
                 "gbif_taxon_database.rds",
                 "itis_higher_taxon_matrices.rds",
                 "itis_taxon_database.rds",
                 "taxon_database.rds")

# load the dbfiles
invisible( sapply(db_files, function(x) readRDS(paste0("database/",x))) )

# load relevant libraries
library(dplyr)
library(readr)
library(tidyr)
library(ggplot2)
library(assertthat)
library(testthat)

# load the test data
dol_df <- readr::read_csv("database/dolmans_MSc_2022.csv")
head(dol_df)

# how many unique taxa are there?
length(unique(dol_df$taxon))

# how many locations?
length(unique(dol_df$location))

# how many countries?
length(unique(dol_df$country_code_XXX))

# check the summary statistics
summary(dol_df)

```

We want to use the body length data to estimate the dry biomass for each of these samples using length-dry biomass allometric equations. The *InvTraitR* package houses a database of more than 350 length-dry biomass allometric equations that represent most major groups of freshwater invertebrates globally. We can use *InvTraitR* to search this database for appropriate length-dry biomass equations for the samples in our test data (`dol_df`).

To do this, we have two options both of which rely on the `get_trait_from_taxon()` function. This function (see below) takes a data.frame with at least five columns. These columns are the taxon name for which dry biomass data are required, the life stage of the taxon, the latitude and longitude coordinates from which the taxon was sampled and body size of the taxon:

```r
get_trait_from_taxon(
    data,                   # data.frame with at least five columns: target taxon, life stage, latitude (dd), longitude (dd) and body size (mm) if trait == "equation"
    target_taxon,           # character string with the column name containing the taxon names
    life_stage,             # character string with the column name containing the life stages
    latitude_dd,            # character string with the column name containing the latitude in decimal degrees
    longitude_dd,           # character string with the column name containing the longitude in decimal degrees
    body_size,              # character string with the column name containing the body size data if trait = "equation"
    workflow = "workflow2", # options are "workflow1" or "workflow2" (default = "workflow2)
    max_tax_dist = 3,       # maximum taxonomic distance acceptable between the target and the taxa in the database (default = 3)
    trait = "equation",     # trait to be searched for (default = "equation")
    gen_sp_dist = 0.5       # taxonomic distance between a genus and a species(default = 0.5)
)
```

### workflow1

The first option is *workflow1*. If *workflow1* is chosen, `get_trait_from_taxon()` will search the database and, for each sample in your dataset, it will output all equations that are within the maximum taxonomic distance (*max_tax_dist*) set by the user. We can then use our own discretion to choose which of these equations we would like to use.

Let's see how this works:

```{r}
# we specify the dol_df into the function
dol_df_equ <- get_trait_from_taxon(data = dol_df,
                                   target_taxon = "taxon",
                                   life_stage = "life_stage",
                                   latitude_dd = "lat",
                                   longitude_dd = "lon",
                                   body_size = "length_mm", 
                                   workflow = "workflow1",
                                   trait = "equation",
                                   max_tax_dist = 3.5,
                                   gen_sp_dist = 0.25)

```


The output is a list of length two with two different data.frames: the data with relevant equations (*data*) and a data.frame with information on how we chose the equations (*decision_df*).

```{r}

# look at the first few rows of both the output data.frames in the list
head(dol_df_equ$data)
head(dol_df_equ$decision_data)

```

We'll start by looking at the outputted data with the equations. To do this, let's simply look at the first row of the raw data. 

```{r}
# check the first row of the data that we fed into the function
print(dol_df[1,])

```

Then, let us compare this with what the function outputs:

```{r}
# check the first row of the output data with the equations
print(dplyr::filter(dol_df_equ$data, row == 1))
```

In this output, we have severals rows for each input row (these are labelled with the row column i.e. input row 1 is labelled has a 1 in the row column). Each row from the input data, there are several rows in this output data. These different rows correspond to different equations from the database that are within the maximum taxonomic distance that we set (i.e. 3.5).

The idea with *workflow1* is for us to now use our discretion to choose appropriate equations. For example, we can use the *tax_distance* column *body_size_range_match* columns to make an initial decision. We want low taxonomic distances and we want the length of our target data to be within the body size range of the equation in the database (which is specified by the *body_size_range_match* column). Based on these criteria, there is a clear winner: equation id = 12 (*id*). The taxonomic distance is zero, it is within the body size range and the equation has an r2 value of 0.93. One issue is that it does not come from the same geographic/habitat conditions (i.e. *realm_match*, *major_habitat_type_match* and *ecoregion_match*).

We can also take guidance from the decision data that is also outputted with workflow1.

```{r}
# check the first row of the decision data
print(dplyr::filter(dol_df_equ$decision_data, row == 1))
```

From this, we can see that the equation we chose (i.e. id = 12) is both recommended by *InvTraitR* (*recommend* column) and would have been the choice made by *workflow2* had we selected it.

Given that we have made our decision, we can now extract the relevant parameters that we need to calculate the dry biomass.

```{r}
ex1 <- 
  dol_df_equ$data |>
  dplyr::filter(row == 1, id == 12) |>
  dplyr::select(row, taxon, life_stage, lat, lon, country_code_XXX,
                location, length_mm,
                equation_form, log_base, a, b, lm_correction, dry_biomass_scale)
```

Using these data, we can simply calculate the expected dry biomass based on the chosen equation as follows:

```{r}
# use with so we can directly reference the variables
dry_biomass_mg <- 
  with(ex1, {
       
          # calculate the raw prediction on the log-scale
          x <- a + (b*logb(x = length_mm, base = log_base))
          
          # convert to the natural scale
          x <- (log_base^x)
          
          # apply the correction factor and scaling factor
          dry_biomass_mg <- 
            ifelse(!is.na(lm_correction), x*lm_correction,x)*dry_biomass_scale
          
          return(dry_biomass_mg)
          
     })

print(paste0("Expected dry biomass (mg) = ", round(dry_biomass_mg, 2) ))

```
We've developed a helper function to automatically perform these calculations based on the following variables in a data.frame.


### workflow2

The second option for obtaining dry biomass estimates for a set of taxa is workflow2 which is our automated workflow for selecting equations. Let's see how this works:

```{r}
# we specify the dol_df into the function and select workflow2
dol_df_equ <- get_trait_from_taxon(data = dol_df,
                                   target_taxon = "taxon",
                                   life_stage = "life_stage",
                                   latitude_dd = "lat",
                                   longitude_dd = "lon",
                                   body_size = "length_mm", 
                                   workflow = "workflow2",
                                   trait = "equation",
                                   max_tax_dist = 3.5,
                                   gen_sp_dist = 0.25)
```

Unlike with *workflow1*, when we open the output data, it has the same number of rows as the input data (i.e. *dol_df*). That is because *InvTraitR* automatically selected an appropriate equation for each row where an appropriate equation was available in the database. Moreover, *InvTraitR* directly calculated the expected dry biomass (see *dry_biomass_mg* column) For example, let's look at the first row:

```{r}
# check the first row of the output data with the equations
print(dplyr::filter(dol_df_equ$data, row == 1))
```

But, as we can see if we look at the whole output, not all rows have equations and this is because *InvTraitR* could not find suitable equations for all input datapoints.

```{r}
print(dol_df_equ$data)
```

In fact, in this dataset, *InvTraitR* was only able to find equations for 22 % of the data points and 23 % of the unique taxa.

```{r}
# proportion of data points for which appropriate equations were found
sum(!is.na(dol_df_equ$data$id))/nrow(dol_df_equ$data)

# proportion of unique taxa for which appropriate equations were found
n <- 
  dplyr::filter(dol_df_equ$data, !is.na(id)) |> 
  dplyr::pull(taxon) |> 
  unique() |> 
  length()

n/length(unique(dol_df_equ$data$taxon))
```
Let's have a look in more detail at the output:

```{r}
View(dol_df_equ$data)
View(dol_df_equ$decision_data)
```

However, we specified certain levels of maximum taxonomic distance in the function. What happens if we relax this and increase the acceptable maximum taxonomic distance and increase it to 4 (instead of 3.5)?

```{r}
# we specify the dol_df into the function and select workflow2
dol_df_equ <- get_trait_from_taxon(data = dol_df,
                                   target_taxon = "taxon",
                                   life_stage = "life_stage",
                                   latitude_dd = "lat",
                                   longitude_dd = "lon",
                                   body_size = "length_mm", 
                                   workflow = "workflow2",
                                   trait = "equation",
                                   max_tax_dist = 4.25,
                                   gen_sp_dist = 0.25)
```

Do we get a higher proportion of datapoint and taxa with appropriate equations?

```{r}
# proportion of data points for which appropriate equations were found
sum(!is.na(dol_df_equ$data$id))/nrow(dol_df_equ$data)

# proportion of unique taxa for which appropriate equations were found
n <- 
  dplyr::filter(dol_df_equ$data, !is.na(id)) |> 
  dplyr::pull(taxon) |> 
  unique() |> 
  length()

n/length(unique(dol_df_equ$data$taxon))
```
In this case, we do not. If this occurs, a user can see which datapoints appropriate equations were not given for and then use the decision data to see if there are appropriate equations for taxa that *InvTraitR* missed. Otherwise, if no good equation can be found, one might have to use order-level equations instead which are available in many research papers (e.g. Benke et al. 1999).



